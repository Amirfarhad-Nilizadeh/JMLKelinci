# JMLKelinci

It is an interface to run AFL fuzzer on Java programs and uses formal methods (OpenJML) to bypass invalid generated inputs. 

JMLKelinci has three advantages in comparison with Kelinci:

1) It makes testing more efficient since it catches and bypasses invalid inputs before running the program under test.
2) by avoiding covering branches with invalid inputs, the tool covers branches to find bugs with valid inputs. Valid inputs are both more efficient to run and more valuable for demonstrating bugs.
3) The initial seed for the fuzzer can be chosen with fewer restrictions. 

This ReadMe assumes that both Kelinci and OpenJML are installed in a Linux system, both work by Java 8. Also, 28 examples from the [Java+JML](https://github.com/Amirfarhad-Nilizadeh/Java-JML) dataset are used in the "example" directory.


# Installation

This application has two main components. First is the fuzzer side (Kelinci) that instruments the Java program, generates new inputs, monitors branch coverage, and discovers crashes in the program. Also, Kelinci itself has two parts, which are Java and C sides. The C part sends the input files generated by AFL to the JAVA side over a TCP connection. It then receives the results and forwards them to AFL. The Java side instruments a target application with AFL style administration, plus a component to communicate with the C side. When executing the instrumented program, this sets up a TCP server and runs the target application in a separate thread for each incoming request. It sends back an exit code (success, timeout, crash, or queue full), plus the gathered path information.

The second component is the OpenJML's runtime assertion checker (RAC). The JML RAC bypasses invalid inputs by evaluating the program's precondition. We assume that the JML precondition of the entry method and any necessary constructors are available. There are some tools available that can infer preconditions for JML, like Daikon. OpenJML's RAC is called in a separate process after inputs are generated with Kelinci. If the precondition is satisfied, then it will run the program under test. Also, if the precondition is not satisfied, Kelinci will generate another input. In JMLKelinci, the process's exit code is queried to determine if the program's precondition was satisfied. 

JMLKelinci is a prototype tool that is created by combining Kelinci and RAC of OpenJML. The RAC is called in the Kelinci's driver. For using JMLKelinci first, two following tools should be installed in a Linux system. Also, both Kelinci and OpenJML are worked with Java 8. 
Two following links are available to install them: 1) [Kelinci](https://github.com/isstac/kelinci) 2) [OpenJML](http://www.openjml.org/).


#Usage

Inputs of JMLKelinci:
1) Java Code
2) Entry Method Precondition
3) Kelinci's Driver
4) Initial seed

"Java Code" is the target program under test. The entry method's precondition can be written manually in JML or using [Daikon](http://plse.cs.washington.edu/daikon/) to infer JML's specification. Kelinci's driver should be written manually to convert the generated byte stream of Kelinci to the program argument types. Also, for checking precondition, the Kelinci's driver needs a method to run the OpenJML's RAC. Kelinci needs an initial seed that does not make the program crash for starting the fuzzing process. Selecting an initial seed for Kelinci is sometimes tricky (for avoiding crash) with a complex structure. However, JMLKelinci does not crash (if the precondition is complete and correct) because it will bypass inputs, making the program crash. 



After installing both Kelinci and OpenJML, follow the following instruction:

1) Start from a root directory of Kelinci (which has "bin" and "bin-instr" directories). 

	$ mkdir jml
	$ cd jml

Create a folder with the name "jml." Then, add a version of the program for compiling with JML's RAC in the jml directory. It must be prepared by taking out the body of the method called by the driver (for avoiding running the program in checking precondition). Also, a JMLDriver should be written manually, which runs the entry method with its precondition.

2) java -jar /~/openjml.jar -rac -racPreconditionEntry *.java

It compiles the entry method with its precondition and JMLDriver.

3) Update the Kelinci's driver by adding a method for calling JMLDriver for checking precondition. (Look at examples that how Kelinci's Driver, JMLDriver, and the added method in the Kelinci's driver are worked)

4) Follow Kelinci's instructions for running Kelinci. By updating the Kelinci's driver and calling JML's RAC, it will bypass invalid inputs.

5) The default of Kelinci is set to use port 7007. The instruction to use different ports to run several fuzzer is available in Kelinci's GitHub system.

6) Kelinci has an option for making the process parallel. The instruction for making the process parallel is in Kelinci's GitHub. 


