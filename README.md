# JMLKelinci

JMLKelinci is a tool that runs the AFL fuzzer on Java programs that
use each program's precondition (written in JML) to bypass invalid generated inputs.

JMLKelinci has three advantages in comparison with Kelinci:

1. It makes testing more efficient since it catches and bypasses invalid inputs before running the program under test.
2. By avoiding covering branches with invalid inputs, the tool finds bugs with valid inputs. Valid inputs are both more efficient to run and more valuable for demonstrating bugs.
3. The initial seed for the fuzzer can be chosen with fewer restrictions. 

Also, 28 examples from the [Java+JML](https://github.com/Amirfarhad-Nilizadeh/Java-JML) dataset used in the NFM paper for running with Kelinci and JMLKelinci are in their corresponding directories. Each program ran 5 times with Kelinci and JMLKelinci; valid generated input tests for each run are collected in a JUnit. 


# Installation

This README assumes that both Kelinci and OpenJML are installed in a Linux system, along with Java 8. 

For using JMLKelinci first, two following tools should be installed in a Linux system. 
Two following links are available to install them: 
1. [Kelinci](https://github.com/isstac/kelinci), and
2. [OpenJML](http://www.openjml.org/).

## Usage

Requirements:

1. Java 8 in a Linux system
2. Kelinci
3. OpenJML

Inputs of JMLKelinci:
1. Java Code
2. Entry Method Precondition
3. Kelinci's Driver
4. Initial seed

The "Java Code" is the target program under test. The entry method's precondition can be written manually in JML (or it could be inferred, e.g., by using [Daikon](http://plse.cs.washington.edu/daikon/)). A Kelinci driver must be written to convert the generated byte stream of Kelinci to the type of the program's arguments. For checking preconditions, the Kelinci driver needs a method to run the OpenJML's RAC (see examples in JMLKelinci directory). Kelinci needs an initial seed that does not make the program crash for starting the fuzzing process. Selecting an initial seed for Kelinci is sometimes tricky (as the seed input must not cause the program to crash), especially if the program's input has a complex structure. However, JMLKelinci does not crash (if the precondition is correct and complete) because it will bypass invalid inputs.

## Running the Tool

After installing both Kelinci and OpenJML, follow the following instruction:

1. Start from the root directory of Kelinci (which has "bin" and "bin-instr" directories), create a folder with the name "jml", and change to it:

	`mkdir jml; cd jml`

Then, add a version of the program for compiling with JML's RAC in the jml directory. The program in the jml directory must be prepared by taking out the body of the method called by the driver (for avoiding running the program in checking precondition). A JMLDriver should also be written manually, which runs the entry method with its precondition (see examples in JMLKelinci directory).

2. Run OpenJML, assuming it is installed in the directory `$OJ`:

	`java -jar $OJ/openjml.jar -rac -racPreconditionEntry *.java`

This command compiles the JMLDriver and entry method with its precondition. It only checks the program's precondition.

3. Update the Kelinci's driver by adding a method for calling JMLDriver for checking precondition. (Look at examples in JMLKelinci directory that how Kelinci's Driver, JMLDriver, and the added method in the Kelinci's driver are worked together)

4. Follow Kelinci's instructions for running Kelinci. By calling JML's RAC in the Kelinci's driver, it will bypass invalid inputs.

5. The default of Kelinci is set to use port 7007. The instruction to use different ports to run several fuzzers in a system is available in Kelinci's GitHub system.

6. Kelinci has an option for making the process parallel. The instruction for making the process parallel is in Kelinci's GitHub. 

# Architecture

The tool has two main components.

The first is the fuzzer side (Kelinci) that instruments the Java program, generates new inputs, monitors branch coverage, and discovers crashes in the program. Also, Kelinci itself has two parts, which are its Java and C parts. The C part sends the input files generated by AFL to the JAVA part over a TCP connection. It then receives the results and forwards them to AFL. The Java side instruments a target application with AFL style administration, plus a component to communicate with the C side. When executing the instrumented program, this sets up a TCP server and runs the target application in a separate thread for each incoming request. It sends back an exit code (success, timeout, crash, or queue full), plus the gathered path information.

The second component is the OpenJML's runtime assertion checker (RAC). The JML RAC bypasses invalid inputs by evaluating the program's precondition. We assume that the JML precondition of the entry method and any necessary constructors are available. There are some tools available that can infer preconditions for JML, like [Daikon](http://plse.cs.washington.edu/daikon/). OpenJML's RAC is called in a separate process after inputs are generated with Kelinci. If the precondition is satisfied, then Kelinci will run and monitor the program under test. Also, if the precondition is not satisfied, Kelinci will generate another input. In JMLKelinci, the process's exit code is queried to determine if the program's precondition was satisfied. 
