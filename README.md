# JMLKelinci

It is an interface to run AFL fuzzer on Java programs and uses formal methods (OpenJML) to bypass invalid generated inputs. 

This ReadMe assumes that both Kelinci and OpenJML are installed in a Linux system, both work by Java 8.

Two following links are available to install them  1) Kelinci 2) OpenJML.

Thirty examples from the Java+JML dataset are used in the "example" directory.


# Installation

This application has two main components. First is the fuzzer side (Kelinci) that instruments the Java program, generates new inputs, monitors branch coverage, and discovers crashes in the program. Also, Kelinci itself has two parts, which are Java and C sides. The C part sends the input files generated by AFL to the JAVA side over a TCP connection. It then receives the results and forwards them to AFL. The Java side instruments a target application with AFL style administration, plus a component to communicate with the C side. When executing the instrumented program, this sets up a TCP server and runs the target application in a separate thread for each incoming request. It sends back an exit code (success, timeout, crash, or queue full), plus the gathered path information.

The second component is the OpenJML's runtime assertion checker (RAC). The JML RAC bypasses invalid inputs by evaluating the program's precondition and throwing an exception if it is not satisfied. We assume that the JML precondition of the entry method and any necessary constructors are available. Also, there are some tools available that can infer preconditions for JML, like Daikon.



