To run JMLKelinci for each example:  

1) Open the "KelinciDriverMain.java" in the "src" directory and update the "String address ="~/jml";" with the address of the "jml" directory in your system and save the file.
 
2) Back to the directory that you can see "src," "bin," "bin-instr," "in_dir," and "jml". 

3) Open a terminal and run the "instrument.sh". Then, open a new terminal and run "startFuzzing.sh". As explained earlier, you should update directory addresses in both shell scripts with the actual address that Kelinci is installed. (Each script has two locations that you should change the address, which are shown with '~')

4) If everything works correctly, after a short time, the AFL interface will start to discover the program's branches with valid inputs. Also, an output directory will be generated ("fuzzer-out" in this study). The fuzzer will save all (interesting) valid inputs in a "queue" subdirectory that triggers different program behaviors (discovering new branches). Also, "crashes" and "hangs" subdirectories will contain valid generated inputs that resulted in a crash or a time-out.

5) To detect semantic bugs, then use RAC of OpenJML and run the program with pre and postconditions and manually enter generated valid inputs. Usually, the valid inputs which cover the buggy branch will be violated.

The "LeapYear.java" is a simple program to start and find how everything is working.

Result: RAC could find bugs in 26 programs with valid inputs, however, generated valid inputs of "FIND_FIRST_IN_SORTED" and "CombinationPermutation" could not detect the bug. In future work, we will expand this study by using postconditions automatically with all valid inputs generated by the guided fuzzer. 
